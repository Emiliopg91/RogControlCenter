#!/usr/bin/env python3
import os
import sys
import json
import subprocess
import logging
from datetime import datetime
from threading import Thread
import time
from urllib.request import urlopen, Request
from urllib.error import URLError, HTTPError


def format_time(segundos) -> str:
    segundos = round(segundos)
    horas, resto = divmod(segundos, 3600)
    minutos, segundos = divmod(resto, 60)
    return f"{horas:02}:{minutos:02}:{segundos:02}"


# === Configuración del logger ===
class CustomFormatter(logging.Formatter):
    def formatTime(self, record, datefmt=None):
        dt = datetime.fromtimestamp(record.created)
        return dt.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]


LOGGER_FILE = os.path.join("{{logger_path}}", "runner.log")
wrapper_formatter = CustomFormatter("[%(asctime)s] %(message)s")
process_formatter = CustomFormatter("\t%(message)s")
logger = logging.getLogger("launcher")
logger.setLevel(logging.INFO)

# Handler a archivo
file_handler = logging.FileHandler(LOGGER_FILE, encoding="utf-8", mode="w")
file_handler.setFormatter(wrapper_formatter)
logger.addHandler(file_handler)

# Handler a consola
console_handler = logging.StreamHandler()
console_handler.setFormatter(wrapper_formatter)
logger.addHandler(console_handler)


def log_input():
    logger.info(">>> Entorno:")
    for key in os.environ:
        logger.info("\t%s=%s", key, os.environ[key])

    logger.info(">>> Command:")
    logger.info("\t%s", " ".join(sys.argv[1:]))


def extract_appid() -> int:
    app_id = None
    for p in command[1:]:
        if p.startswith("AppId="):
            app_id = p.split("=")[1]
            break
    return app_id


def query_for_app_cfg(app_id: int):
    env_vars = []
    wrappers = []
    args = ""
    try:
        logger.info("Sending config query for AppId %s", app_id)
        API_URL = f"http://localhost:{{port}}/getParamRunningApp/{app_id}"
        req = Request(
            API_URL,
            headers={"Accept": "application/json"},
        )
        with urlopen(req) as response:
            config = json.load(response)
        env_vars = config.get("environment", {})
        wrappers = config.get("wrappers", [])
        args = config.get("parameters", "")

        logger.info(">>> Configuración descargada:")
        logger.info("\tEnvironment:")

        for key in env_vars:
            logger.info("\t\t%s=%s", key, env_vars[key])

        env_vars["OVERRIDE_FLATPAK_ENV"] = ",".join(env_vars.keys())
        logger.info("\tWrappers:")
        for wrapper in wrappers:
            logger.info("\t\t%s", wrapper)

        logger.info("\tParameters:")
        logger.info("\t\t%s", args)

        return (env_vars, wrappers, args)
    except (URLError, HTTPError) as e:
        logger.warning("Error fetching config from %s: %s", API_URL, e)
    except Exception as e:
        logger.warning("Unexpected error during config fetch: %s", e)
    return (env_vars, wrappers, args)


def query_for_app_renice():
    try:
        logger.info("Request renice for %s", os.getpid())
        API_URL = f"http://localhost:{{port}}/renice/{os.getpid()}"
        req = Request(
            API_URL,
            headers={"Accept": "application/json"},
        )
        with urlopen(req) as response:
            json.load(response)

    except (URLError, HTTPError) as e:
        logger.warning("Error on renice from %s: %s", API_URL, e)
    except Exception as e:
        logger.warning("Unexpected error during renice: %s", e)


def run_command(command: list[str], child_env: dict[str, str]):
    logger.info(">>> Running command: ")
    logger.info("\t%s", " ".join(command))
    start_time = time.time()

    def _handle_output(stream, prefix):
        for line in iter(stream.readline, b""):
            logger.info(line.decode(errors="replace").rstrip())

    try:
        console_handler.setFormatter(process_formatter)
        file_handler.setFormatter(process_formatter)

        with subprocess.Popen(command, env=child_env, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as process:
            stdout_thread = Thread(target=_handle_output, args=(process.stdout, "[STDOUT]"))
            stderr_thread = Thread(target=_handle_output, args=(process.stderr, "[STDERR]"))

            stdout_thread.start()
            stderr_thread.start()

            exit_code = process.wait()

            stdout_thread.join()
            stderr_thread.join()
    except FileNotFoundError:
        exit_code = 127
        logger.error("Command not found: %s", command[0])
    except Exception as e:
        exit_code = 1
        logger.error("Error running command: %s", e)
    finally:
        console_handler.setFormatter(wrapper_formatter)
        file_handler.setFormatter(wrapper_formatter)

    end_time = time.time()

    logger.info(">>> Finished after %s", format_time(end_time - start_time))
    logger.info(">>> Exit code: %d", exit_code)

    return exit_code


try:
    if len(sys.argv) < 2:
        logger.error("Error: no command provided")
        sys.exit(1)

    logger.info("===== Lanzamiento iniciado =====")
    log_input()

    child_env = os.environ.copy()
    child_env["PATH"] = os.path.dirname(__file__) + os.pathsep + child_env["PATH"]

    command = sys.argv[1:]

    app_id = extract_appid()

    if app_id is not None:
        (env, wrap, args) = query_for_app_cfg(app_id)
        child_env.update(env)
        command = wrap + sys.argv[1:]
        command.append(args)
    else:
        logger.warning("No AppId provided")

    query_for_app_renice()

    sys.exit(run_command(command, child_env))
except Exception as e:
    logger.error("General error: %s", e)
